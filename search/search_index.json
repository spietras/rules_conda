{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"rules_conda \ud83d\udd17 Rules for creating conda environments in Bazel \ud83d\udc9a See here for usage example. Who should use this? \ud83d\udd17 These rules allow you to download and install conda , create conda environments and register Python toolchain from environments. This means you can achieve truly reproducible and hermetic local python environments. Only Python 3 is supported. Pros: easy to use no existing conda installation necessary no global conda installation, no global PATH modifications virtually impossible to corrupt your environment by mistake as it always reflects your environment.yml all Python targets will implicitly have access to the whole environment (the one registered in toolchain) Cons: every time you update your environment configuration in environment.yml , the whole environment will be recreated from scratch (but cached package data can be reused) on Windows you need to add environment location to PATH or set CONDA_DLL_SEARCH_MODIFICATION_ENABLE=1 during runtime, so DLLs can be loaded properly (more on that here ) So I think these rules suit you if: you want to use Bazel (e.g. you fell into Python monorepo trap) you want to use conda for Python environment management you don't want to set up your Python environment manually or want your Python targets to just work on clean systems you are okay with environments being recreated every time something changes you use Python 3 Requirements \ud83d\udd17 rules_conda don't have any strict requirements by themselves. Just make sure you are able to use conda .","title":"Home"},{"location":"#rules_conda","text":"Rules for creating conda environments in Bazel \ud83d\udc9a See here for usage example.","title":"rules_conda"},{"location":"#who-should-use-this","text":"These rules allow you to download and install conda , create conda environments and register Python toolchain from environments. This means you can achieve truly reproducible and hermetic local python environments. Only Python 3 is supported. Pros: easy to use no existing conda installation necessary no global conda installation, no global PATH modifications virtually impossible to corrupt your environment by mistake as it always reflects your environment.yml all Python targets will implicitly have access to the whole environment (the one registered in toolchain) Cons: every time you update your environment configuration in environment.yml , the whole environment will be recreated from scratch (but cached package data can be reused) on Windows you need to add environment location to PATH or set CONDA_DLL_SEARCH_MODIFICATION_ENABLE=1 during runtime, so DLLs can be loaded properly (more on that here ) So I think these rules suit you if: you want to use Bazel (e.g. you fell into Python monorepo trap) you want to use conda for Python environment management you don't want to set up your Python environment manually or want your Python targets to just work on clean systems you are okay with environments being recreated every time something changes you use Python 3","title":"Who should use this?"},{"location":"#requirements","text":"rules_conda don't have any strict requirements by themselves. Just make sure you are able to use conda .","title":"Requirements"},{"location":"usage/api/","text":"API \ud83d\udd17 load_conda \ud83d\udd17 Downloads conda . Parameters: Name Description Default conda_version Version of conda to download 4.10.3 installer Which conda installer to download, either miniconda or miniforge miniconda install_mamba Whether to install mamba , which is a faster drop-in replacement for conda False mamba_version Version of mamba to install 0.17.0 quiet True if conda output should be hidden True timeout How many seconds each execute action can take 3600 conda_create \ud83d\udd17 Creates a conda environment. Parameters: Name Description Default name Name of the environment environment label pointing to environment configuration file (typically named environment.yml ) quiet True if conda output should be hidden True timeout How many seconds each execute action can take 3600 clean True if conda cache should be cleaned (less space taken, but slower subsequent builds) False use_mamba Whether to use mamba to create the conda environment. If this is True , install_mamba must also be True False register_toolchain \ud83d\udd17 Register python toolchain from conda environment for all python targets to use. Parameters: Name Description Default env Name of the environment to use","title":"API"},{"location":"usage/api/#api","text":"","title":"API"},{"location":"usage/api/#load_conda","text":"Downloads conda . Parameters: Name Description Default conda_version Version of conda to download 4.10.3 installer Which conda installer to download, either miniconda or miniforge miniconda install_mamba Whether to install mamba , which is a faster drop-in replacement for conda False mamba_version Version of mamba to install 0.17.0 quiet True if conda output should be hidden True timeout How many seconds each execute action can take 3600","title":"load_conda"},{"location":"usage/api/#conda_create","text":"Creates a conda environment. Parameters: Name Description Default name Name of the environment environment label pointing to environment configuration file (typically named environment.yml ) quiet True if conda output should be hidden True timeout How many seconds each execute action can take 3600 clean True if conda cache should be cleaned (less space taken, but slower subsequent builds) False use_mamba Whether to use mamba to create the conda environment. If this is True , install_mamba must also be True False","title":"conda_create"},{"location":"usage/api/#register_toolchain","text":"Register python toolchain from conda environment for all python targets to use. Parameters: Name Description Default env Name of the environment to use","title":"register_toolchain"},{"location":"usage/example/","text":"Example usage \ud83d\udd17 Let's say you want to write some python code. The simplest structure would be something like this: BUILD environment.yml main.py WORKSPACE First get familiar with rules_python . You should uses these rules to configure your Python project to work with Bazel. I recommend that you first set everything up so that it works with your local Python. After that works you can move to using rules_conda for creating environments automatically. To use rules_conda you need to add that to your WORKSPACE file and put appropriate values taken from chosen release : load ( \"@bazel_tools//tools/build_defs/repo:http.bzl\" , \"http_archive\" ) http_archive ( name = \"rules_conda\" , sha256 = \"...\" , # copy from release url = \"...\" , # copy from release ) load ( \"@rules_conda//:defs.bzl\" , \"conda_create\" , \"load_conda\" , \"register_toolchain\" ) load_conda ( quiet = False ) conda_create ( name = \"env\" , environment = \"@//:environment.yml\" , quiet = False , ) register_toolchain ( env = \"env\" ) This will download conda , create your environment and register it so that all Python targets can use it by default. Now if you configured everything correctly, you can run: bazel run main This will run main.py inside the created environment. If environment configuration doesn't change then subsequent runs will simply reuse the environment. Otherwise the environment will be recreated from scratch, so that it always reflects the configuration. However, if the clean flag is set to False (the default) in conda_create then the downloaded package data will be reused so you don't need to download everything everytime. Also see here for a complete example with all the code available. Advanced example \ud83d\udd17 This example shows all possibilities of rules_conda : load ( \"@bazel_tools//tools/build_defs/repo:http.bzl\" , \"http_archive\" ) http_archive ( name = \"rules_conda\" , sha256 = \"...\" , # copy from release url = \"...\" , # copy from release ) load ( \"@rules_conda//:defs.bzl\" , \"conda_create\" , \"load_conda\" , \"register_toolchain\" ) load_conda ( conda_version = \"4.10.3\" , # version of conda to download, default is 4.10.3 installer = \"miniforge\" , # which conda installer to download, either miniconda or miniforge, default is miniconda install_mamba = True , # whether to install mamba, which is a faster drop-in replacement for conda, default is False mamba_version = \"0.17.0\" , # version of mamba to install, default is 0.17.0 quiet = False , # True if conda output should be hidden, default is True timeout = 600 , # how many seconds each execute action can take, default is 3600 ) conda_create ( name = \"env\" , # name of the environment environment = \"@//:environment.yml\" , # label pointing to environment configuration file use_mamba = True , # Whether to use mamba to create the conda environment. If this is True, install_mamba must also be True clean = False , # True if conda cache should be cleaned (less space taken, but slower subsequent builds), default is False quiet = False , # True if conda output should be hidden True, default is True timeout = 600 , # how many seconds each execute action can take, default is 3600 ) register_toolchain ( env = \"env\" )","title":"Example"},{"location":"usage/example/#example-usage","text":"Let's say you want to write some python code. The simplest structure would be something like this: BUILD environment.yml main.py WORKSPACE First get familiar with rules_python . You should uses these rules to configure your Python project to work with Bazel. I recommend that you first set everything up so that it works with your local Python. After that works you can move to using rules_conda for creating environments automatically. To use rules_conda you need to add that to your WORKSPACE file and put appropriate values taken from chosen release : load ( \"@bazel_tools//tools/build_defs/repo:http.bzl\" , \"http_archive\" ) http_archive ( name = \"rules_conda\" , sha256 = \"...\" , # copy from release url = \"...\" , # copy from release ) load ( \"@rules_conda//:defs.bzl\" , \"conda_create\" , \"load_conda\" , \"register_toolchain\" ) load_conda ( quiet = False ) conda_create ( name = \"env\" , environment = \"@//:environment.yml\" , quiet = False , ) register_toolchain ( env = \"env\" ) This will download conda , create your environment and register it so that all Python targets can use it by default. Now if you configured everything correctly, you can run: bazel run main This will run main.py inside the created environment. If environment configuration doesn't change then subsequent runs will simply reuse the environment. Otherwise the environment will be recreated from scratch, so that it always reflects the configuration. However, if the clean flag is set to False (the default) in conda_create then the downloaded package data will be reused so you don't need to download everything everytime. Also see here for a complete example with all the code available.","title":"Example usage"},{"location":"usage/example/#advanced-example","text":"This example shows all possibilities of rules_conda : load ( \"@bazel_tools//tools/build_defs/repo:http.bzl\" , \"http_archive\" ) http_archive ( name = \"rules_conda\" , sha256 = \"...\" , # copy from release url = \"...\" , # copy from release ) load ( \"@rules_conda//:defs.bzl\" , \"conda_create\" , \"load_conda\" , \"register_toolchain\" ) load_conda ( conda_version = \"4.10.3\" , # version of conda to download, default is 4.10.3 installer = \"miniforge\" , # which conda installer to download, either miniconda or miniforge, default is miniconda install_mamba = True , # whether to install mamba, which is a faster drop-in replacement for conda, default is False mamba_version = \"0.17.0\" , # version of mamba to install, default is 0.17.0 quiet = False , # True if conda output should be hidden, default is True timeout = 600 , # how many seconds each execute action can take, default is 3600 ) conda_create ( name = \"env\" , # name of the environment environment = \"@//:environment.yml\" , # label pointing to environment configuration file use_mamba = True , # Whether to use mamba to create the conda environment. If this is True, install_mamba must also be True clean = False , # True if conda cache should be cleaned (less space taken, but slower subsequent builds), default is False quiet = False , # True if conda output should be hidden True, default is True timeout = 600 , # how many seconds each execute action can take, default is 3600 ) register_toolchain ( env = \"env\" )","title":"Advanced example"},{"location":"usage/issues/","text":"Issues \ud83d\udd17 PATH issue \ud83d\udd17 With usual conda usage, you should activate you environment before doing anything. Activating an environment prepends some paths to PATH variable. This is crucial on Windows, because some conda packages need to load DLLs, which are stored in conda environments and the path to them must be in PATH variable for Windows to properly load them. On Linux, it somehow works without having to modify PATH . But here comes the issue: at this moment, I'm not aware of any way to either activate an environment before launching Python targets or adding anything to PATH automatically by Bazel. So the user has to do something to resolve the PATH issue. There are two ways: Modify PATH Before running the target, set the PATH to include the path to your_env/Library/bin . For example: cmd /C \"set PATH={full path to workspace}\\bazel-{name}\\external\\{env_name}\\{env_name}\\Library\\bin;%PATH%&& bazel run {target}\" Use CONDA_DLL_SEARCH_MODIFICATION_ENABLE It originally stems from another issue, but Python from conda has the ability to automatically insert the correct entries to PATH . This is controlled by setting the CONDA_DLL_SEARCH_MODIFICATION_ENABLE to 1 . So you can for example do: cmd /C \"set CONDA_DLL_SEARCH_MODIFICATION_ENABLE=1&& bazel run {target}\" This method only works with newer Python builds. More information here . In the future I hope that either conda (or Python, or Windows DLL loading, whatever is responsible for that) will change to work without activation or it will be possible to set environmetal variables inside Bazel.","title":"Issues"},{"location":"usage/issues/#issues","text":"","title":"Issues"},{"location":"usage/issues/#path-issue","text":"With usual conda usage, you should activate you environment before doing anything. Activating an environment prepends some paths to PATH variable. This is crucial on Windows, because some conda packages need to load DLLs, which are stored in conda environments and the path to them must be in PATH variable for Windows to properly load them. On Linux, it somehow works without having to modify PATH . But here comes the issue: at this moment, I'm not aware of any way to either activate an environment before launching Python targets or adding anything to PATH automatically by Bazel. So the user has to do something to resolve the PATH issue. There are two ways: Modify PATH Before running the target, set the PATH to include the path to your_env/Library/bin . For example: cmd /C \"set PATH={full path to workspace}\\bazel-{name}\\external\\{env_name}\\{env_name}\\Library\\bin;%PATH%&& bazel run {target}\" Use CONDA_DLL_SEARCH_MODIFICATION_ENABLE It originally stems from another issue, but Python from conda has the ability to automatically insert the correct entries to PATH . This is controlled by setting the CONDA_DLL_SEARCH_MODIFICATION_ENABLE to 1 . So you can for example do: cmd /C \"set CONDA_DLL_SEARCH_MODIFICATION_ENABLE=1&& bazel run {target}\" This method only works with newer Python builds. More information here . In the future I hope that either conda (or Python, or Windows DLL loading, whatever is responsible for that) will change to work without activation or it will be possible to set environmetal variables inside Bazel.","title":"PATH issue"}]}