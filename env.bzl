load(":utils.bzl", "CONDA_EXT_MAP", "EXECUTE_TIMEOUT", "PYTHON_EXT_MAP", "get_os")

BUILD_FILE_CONTENT = """# This file was automatically generated by rules_conda
package(default_visibility = ["//visibility:public"])

load("@bazel_tools//tools/python:toolchain.bzl", "py_runtime_pair")

py_runtime(
    name = "python_runtime",
    files = glob(["{env_path}/**/*"], exclude_directories = 0),
    interpreter = "{env_path}/{interpreter_path}",
    python_version = "PY{py_major}"
)
"""

# clean conda caches and unused packages
def _clean(rctx, executable):
    rctx.report_progress("Cleaning up")

    args = [rctx.path(executable), "clean", "-a", "-y"]

    result = rctx.execute(args, quiet = rctx.attr.quiet, timeout = rctx.attr.timeout)
    if result.return_code:
        fail("Failure cleaning up.\nstdout: {}\nstderr: {}".format(result.stdout, result.stderr))

# create new local conda environment from file
def _create_environment(rctx, executable, env_name):
    rctx.report_progress("Creating conda environment")

    # path to env file as string
    env_file = str(rctx.path(rctx.attr.environment))

    args = [rctx.path(executable), "env", "create", "-f", env_file, "-p", "./{}".format(env_name)]

    result = rctx.execute(args, quiet = rctx.attr.quiet, timeout = rctx.attr.timeout)
    if result.return_code:
        fail("Failure creating environment.\nstdout: {}\nstderr: {}".format(result.stdout, result.stderr))

# check if python2 or python3 has been installed
def _get_py_major(rctx, env_path, interpreter_path):
    interpreter = "{}/{}".format(env_path, interpreter_path)
    result = rctx.execute([rctx.path(interpreter), "--version"], timeout = rctx.attr.timeout)
    output = result.stdout if result.stdout else result.stderr
    return int(output.replace("Python ", "").partition(".")[0])

# create BUILD file with py_runtime
def _create_env_build_file(rctx, env_name):
    os = get_os(rctx)
    python_executable = "python{}".format(PYTHON_EXT_MAP[os])
    interpreter_path = python_executable if os == "Windows" else "bin/{}".format(python_executable)
    py_major = _get_py_major(rctx, env_name, interpreter_path)
    rctx.file(
        "BUILD",
        content = BUILD_FILE_CONTENT.format(
            env_path = env_name,
            interpreter_path = interpreter_path,
            py_major = py_major,
        ),
    )

def _conda_create_impl(rctx):
    conda_label = Label("@{}//:{}/condabin/conda{}".format(rctx.attr.conda_repo, rctx.attr.conda_dir, CONDA_EXT_MAP[get_os(rctx)]))
    executable = str(rctx.path(conda_label))
    env_name = rctx.name
    _create_environment(rctx, executable, env_name)
    if rctx.attr.clean:
        _clean(rctx, executable)
    _create_env_build_file(rctx, env_name)

conda_create_rule = repository_rule(
    _conda_create_impl,
    attrs = {
        "conda_repo": attr.string(mandatory = True),
        "conda_dir": attr.string(mandatory = True),
        "environment": attr.label(
            mandatory = True,
            allow_single_file = True,
            doc = "The label of the environment.yml file.",
        ),
        "quiet": attr.bool(
            default = True,
            doc = "False if conda output should be shown",
        ),
        "timeout": attr.int(
            default = EXECUTE_TIMEOUT,
            doc = "Timeout in seconds for each execute action",
        ),
        "clean": attr.bool(
            default = True,
            doc = "False if conda cache should not be cleaned",
        ),
    },
)
